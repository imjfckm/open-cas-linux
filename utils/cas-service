#!/usr/bin/env python3
#
# Copyright(c) 2012-2021 Intel Corporation
# SPDX-License-Identifier: BSD-3-Clause-Clear
#

import opencas
import sys
import os
import syslog as sl
import socket
import time
from concurrent.futures import ThreadPoolExecutor as tpe

def prepare_service_socket(service_addr):
    try:
        os.unlink(service_addr)
    except:
        pass
    service_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    service_socket.bind(service_addr)
    service_socket.listen(1)

    return service_socket

class ServiceSocket:
    def __init__(self, service_addr):
        try:
            os.unlink(service_addr)
        except:
            pass
        service_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        service_socket.bind(service_addr)
        service_socket.listen(1)
        service_socket.settimeout(1)

        self.socket = service_socket

    def wait_udev_notification(self):
        try:
            conn, addr = self.socket.accept()
            conn.settimeout(1)
            data = conn.recv(4096)
            self.conn = conn
            return True
        except socket.timeout:
            return False

    def notify_udev(self):
        if not self.conn:
            return

        self.conn.sendall(b"DONE\n")
        self.conn.close()
        self.conn = None

class SdNotifySocket:
    def __init__(self, notify_addr):
        if notify_addr.startswith("@"):
            notify_addr = "\0" + notify_addr[1:]
        notify_socket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
        notify_socket.connect(notify_addr)

        self.socket = notify_socket

    def _send_msg(self, msg):
        self.socket.sendall(msg.encode("ascii"))

    def send_ready(self):
        self._send_msg("READY=1\n")

    def send_status(self, status):
        print(status, file=sys.stderr)
        self._send_msg(f"STATUS={status}\n")

    def extend_timeout(self, timeout):
        self._send_msg(f"EXTEND_TIMEOUT_USEC={timeout*10000000}\n")


def main(unit_type, unit_id, unit_dev):

    notify_socket = SdNotifySocket(os.getenv("NOTIFY_SOCKET"))
    service_socket = ServiceSocket(
            f"/var/cas_{unit_type}{unit_id}.sock"
    )

    try:
        config = opencas.cas_config.from_file('/etc/opencas/opencas.conf',
                                              allow_incomplete=True)
    except Exception as e:
        notify_socket.send_status(f'Unable to load opencas config. Reason: {str(e)}')
        exit(1)

    target_device = None
    if unit_type == "cache":
        cache_id, core_id = int(unit_id), None
    else:
        cache_id, core_id = map(int, unit_id.split("-"))

    target_device = config.caches[cache_id].cores[core_id] if core_id else config.caches[cache_id]

    dev_appeared = os.path.exists(target_device.device)
    started = False
    starting_job = None
    cb = lambda: None

    while not started:
        if starting_job:
            if starting_job.running():
                notify_socket.extend_timeout(15)
                notify_socket.send_status("Waiting for starting job to end")
                time.sleep(10)
                continue

            started, msg = starting_job.result()
            if started:
                msg = f"Successfully started {unit_type} on {target_device.device}"
            elif "is already" in msg:
                started = True
                msg = f"Already started {unit_type} on {target_device.device}"

            notify_socket.send_status(msg)

        if dev_appeared and not started:
            executor = tpe()
            notify_socket.send_status("Attempting to start the device")
            starting_job = executor.submit(opencas.start_device, target_device)
            time.sleep(2)
            cb()
            cb = lambda: None

        if not starting_job:
            notify_socket.send_status(f"Waiting for device {target_device.device}")
            d = service_socket.wait_udev_notification()
            if d:
                notify_socket.send_status("Device {target_device.device} appeared")
            dev_appeared = d
            cb = lambda: service_socket.notify_udev()

    notify_socket.send_ready()

if __name__ == "__main__":
    unit_type, unit_id, unit_dev = sys.argv[1:]
    main(unit_type, unit_id, unit_dev)
